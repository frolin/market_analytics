c
diff_text
c
photo_path
c
@source.photos.first.image.storage.path(@source.photos.first.image.id).to_sc
@source.photos.first.image.storage.path(@source.photos.first.image.id).path
@source.photos.first.image.storage.path(@source.photos.first.image.id)
@source.photos.first.image.storage.path
@source.photos.first.image.storage
@source.photos.first.storage
@source.photos.first.file
@source.photos.first.image.filename
@source.photos.first.image.path
@source.photos.first.image.io
@source.photos.first.image
@source.photos.first.metadata
@source.photos.first.filename
@source.photos.first.file
@source.photos.first.io
@source.photos.first.io.path
@source.photos.first.data
@source.photos.first
image_path(@source.photos.first)
@source.photos.first.path
@source.photos.first.file
@source.photos.first.file_path
@source.photos.first.path
@source.photos.first
param
params
c
next
diff_data
c
I18n.t("telegram.notifications.new_diff_parsed_data.#{k}", before: v.first, after: v.last )
c
I18n.t("telegram.notifications.new_diff_parsed_data.#{k}", before: v.first, after: v.last )
k
c
diff_data
field_name
c
diff_data.first.valuesc
diff_data.first.values
diff_data.first.values.keys
diff_data.first.values
diff_data.values
diff.values
diff.values.keys
diff.values
diff
diff[:before]
diff[:before].key
c
@source.requests
I18n.t("telegram.notifications.new_diff_parsed_data")
diff
c
result
c
result
c
result
c 
last_data
previous_data
result
c
last_data.data["final_price"]
last_data["final_price"]
result
result.compact
c
reload!
last_data["final_price"]
last_data[["final_price"]
uniq_keys
result.compact
c
result.compact
result
c
reload!
result
c
reload!
previous_data.data
previous_data
\source
source
(previous_data.data.keys | last_data.data.keys)
result
c
next
c
previous_data.data
previous_data
previous
last_data.data
(previous_data.data.keys | last_data.data.keys).select { |key| previous_data[key] != last_data[key] }
ld
ld.save!
ld.url = '123'
ld = last_data
url
url = last_data.url = 'asd'
url = last_data.url
last_data.url
last_data.data
last_data
previous_data.data.keys
(previous_data.data.keys | last_data.data.keys).select { |key| previous_data[key] != last_data[key] }
reload!
(previous_data.keys | last_data.keys).select { |key| previous_data[key] != last_data[key] }
previous_data, last_data = @source.requests.last(2)
previous_data
last_data
next
c
reload!
diff_data
c
next
c
self.class
self.class.count
c
next
last_data
next
previous_data
next
c
(previous_data.keys | last_data.keys).select { |key| previous_data[key] != last_data[key] }
next
self.data
self.source.requests.second_to_last.data
c
check_store.errors
check_store.valid?
next
c
next
store.id
next
c
find_images
c
@reviews_count
next
result
next
c
@image_urls
c
@image_urls
c
 element_is_displayed?(type: :css, name: SEARCH_CSS[:images]) do
          @page.find_elements(css: SEARCH_CSS[:images]).map { |image| image.attribute('src') }
        end
find_images
c
 def find_images
        element_is_displayed?(type: :css, name: SEARCH_CSS[:images]) do
          return @page.find_elements(css: SEARCH_CSS[:images]).map { |image| image.attribute('src') }
        end
      end
c
find_inages
find_images
find_inage
def find_inages
        element_is_displayed?(type: :css, name: SEARCH_CSS[:images]) do
          return @page.find_elements(css: SEARCH_CSS[:images]).map { |image| image.attribute('src') }
        end
      end
@image_urls
next
c
rating
title
next
element_found
next
name
type
next
c
@stores
c
@stores
c
@stores
c
params[:user_id]
params
c
SEARCH_CSS[:review_count]
element_is_displayed?(type: :css, name: SEARCH_CSS[:review_count])
@page.find_element(css: SEARCH_CSS[:reviews_count]).text
SEARCH_CSS[:reviews_count]
reviews_count = find_review_count
l
c
params
c
bot
c
ENV.fetch('BOT_NAME', :dev_chat)
bot
c
bot
c
users
c
params
users
c
exit
users
c
params[:user_ids]
TgUser.where(id: 1)
TgUser.where(id: params[:user_ids])
TgUser.where(id: params[:user_ids].uniq)
TgUser.all
params
users
c
us
s
users
c
next
c
diff_data
c
(hash1.keys | hash2.keys).select{ |key| hash1[key] != hash2[key] }
hash1["final_price"] = 1
(hash1.keys | hash2.keys).select{ |key| hash1[key] != hash2[key] }
hash2 = self.data
hash1 = self.source.requests.second_to_last.data
prev.
prev.class?
self.data.class
self.data
prev.diff(self.data)
prev = self.source.requests.second_to_last.data
self.source.requests.second_to_last.data
self.source.requests.second_to_last
self.source.requests.last
self.source.request.last
self.source
source
c
